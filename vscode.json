{
    "snippet-czip": {
        "prefix": "czip",
        "body": "func createZip(name string, files []string) error {\n\tzipFile, err := os.Create(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zipFile.Close()\n\n\tzWriter := zip.NewWriter(zipFile)\n\n\tfor _, fName := range files {\n\t\treader, err := os.Open(fName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\twriter, err := zWriter.Create(fName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.Copy(writer, reader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err = reader.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = zWriter.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "description": "Create zip file"
    },
    "snippet-ezip": {
        "prefix": "ezip",
        "body": "func extractZip(name string, extractTo string) error {\n\tzReader, err := zip.OpenReader(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer zReader.Close()\n\n\tif err = os.MkdirAll(extractTo, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, f := range zReader.File {\n\t\tdestpath := filepath.Join(extractTo, f.Name)\n\n\t\tif !strings.HasPrefix(destpath, filepath.Clean(extractTo)+string(os.PathSeparator)) {\n\t\t\treturn errors.New(\"zip slip\")\n\t\t}\n\n\t\trc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif f.FileInfo().IsDir() {\n\t\t\tif err = os.MkdirAll(destpath, os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err = os.MkdirAll(filepath.Dir(destpath), os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\textractedF, err := os.Create(destpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif _, err = io.Copy(extractedF, rc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = extractedF.Close(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif err = rc.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
        "description": "Extract zip file"
    },
    "snippet-ctar": {
        "prefix": "ctar",
        "body": "func createTar(name string, files []string) error {\n\tfWriter, err := os.Create(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fWriter.Close()\n\n\twriter := tar.NewWriter(fWriter)\n\n\tfor _, fName := range files {\n\t\treader, err := os.Open(fName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tstat, err := reader.Stat()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thdr := &tar.Header{\n\t\t\tName: fName,\n\t\t\tMode: 0600,\n\t\t\tSize: stat.Size(),\n\t\t}\n\t\tif err := writer.WriteHeader(hdr); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := io.Copy(writer, reader); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err = reader.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err = writer.Close(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "description": "Create tar file"
    },
    "snippet-etar": {
        "prefix": "etar",
        "body": "func extractTar(name string, extractTo string) error {\n\tfReader, err := os.Open(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fReader.Close()\n\n\treader := tar.NewReader(fReader)\n\n\tif err = os.MkdirAll(extractTo, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\thdr, err := reader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdestpath := filepath.Join(extractTo, hdr.Name)\n\t\tif !strings.HasPrefix(destpath, filepath.Clean(extractTo)+string(os.PathSeparator)) {\n\t\t\treturn errors.New(\"zip slip\")\n\t\t}\n\n\t\tif hdr.FileInfo().IsDir() {\n\t\t\tif err = os.MkdirAll(destpath, os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err = os.MkdirAll(filepath.Dir(destpath), os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\twriter, err := os.Create(destpath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif _, err = io.Copy(writer, reader); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
        "description": "Extract tar file"
    },
    "snippet-esymmetric": {
        "prefix": "esymmetric",
        "body": "func encryptSymmetric(hashedPassword []byte, plaintext []byte) ([]byte, error) {\n\tblock, err := aes.NewCipher(hashedPassword)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnonce := make([]byte, 12)\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn nil, err\n\t}\n\n\taesgcm, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn aesgcm.Seal(nil, nonce, plaintext, nil), nil\n}",
        "description": "Symmetric encryption"
    },
    "snippet-connselfsigned": {
        "prefix": "connselfsigned",
        "body": "func connectSelfSignedHost(selfSignedPEM []byte, addr string) (*tls.Conn, error) {\n\troots := x509.NewCertPool()\n\n\tok := roots.AppendCertsFromPEM([]byte(selfSignedPEM))\n\tif !ok {\n\t\treturn nil, errors.New(\"append cert failed\")\n\t}\n\n\treturn tls.Dial(\"tcp\", addr, &tls.Config{RootCAs: roots})\n}",
        "description": "Connect self signed host"
    },
    "snippet-cquery": {
        "prefix": "cquery",
        "body": "func query(ctx context.Context, db *sql.DB, id int, limit int) ([]int64, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT id FROM users WHERE id > ? LIMIT ?\", id, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tresults := make([]int64, 0, limit)\n\tfor rows.Next() {\n\t\tvar id int64\n\t\trows.Scan(&id)\n\t\tresults = append(results, id)\n\t}\n\treturn results, nil\n}",
        "description": "Context sql query"
    },
    "snippet-cqueryrow": {
        "prefix": "cqueryrow",
        "body": "func queryRow(ctx context.Context, db *sql.DB, id int) (string, error) {\n\tvar name string\n\terr := db.QueryRowContext(ctx, \"SELECT name FROM users WHERE id = ?\").Scan(&name)\n\treturn name, err\n}",
        "description": "Context sql row query"
    },
    "snippet-cinsertsql": {
        "prefix": "cinsertsql",
        "body": "func insertRows(ctx context.Context, db *sql.DB, rows []string) error {\n\ttx, err := db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstmt, err := tx.PrepareContext(ctx, \"INSERT INTO users (name) VALUES (?)\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, row := range rows {\n\t\t_, err := stmt.ExecContext(ctx, row)\n\t\tif err != nil {\n\t\t\tif err = tx.Rollback(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "description": "Context sql insert"
    }
}